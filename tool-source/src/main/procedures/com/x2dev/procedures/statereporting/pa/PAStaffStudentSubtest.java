/*
 * ====================================================================
 *
 * Follett Software Company
 *
 * Copyright (c) 2017 Follett Software Company
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, is not permitted without a written agreement
 * from Follett Software Company.
 *
 * ====================================================================
 */

package com.x2dev.procedures.statereporting.pa;

import static com.follett.fsc.core.k12.business.ModelProperty.PATH_DELIMITER;
import com.follett.fsc.core.framework.persistence.BeanQuery;
import com.follett.fsc.core.framework.persistence.SubQuery;
import com.follett.fsc.core.framework.persistence.X2Criteria;
import com.follett.fsc.core.k12.beans.ExtendedDataDictionary;
import com.follett.fsc.core.k12.beans.ReferenceCode;
import com.follett.fsc.core.k12.beans.ReferenceTable;
import com.follett.fsc.core.k12.beans.ReportQueryIterator;
import com.follett.fsc.core.k12.beans.SchoolCalendar;
import com.follett.fsc.core.k12.beans.X2BaseBean;
import com.follett.fsc.core.k12.business.StudentManager;
import com.follett.fsc.core.k12.business.X2Broker;
import com.follett.fsc.core.k12.business.dictionary.DataDictionary;
import com.follett.fsc.core.k12.business.dictionary.DataDictionaryField;
import com.follett.fsc.core.k12.tools.stateexports.FieldDefinition;
import com.follett.fsc.core.k12.tools.stateexports.FieldRetriever;
import com.follett.fsc.core.k12.tools.stateexports.FieldValidator;
import com.follett.fsc.core.k12.tools.stateexports.StateReportData;
import com.follett.fsc.core.k12.tools.stateexports.StateReportEntity;
import com.follett.fsc.core.k12.web.AppGlobals;
import com.x2dev.procedures.statereporting.pa.PAStaffStudentSubtest.PAStaffStudentSubtestEntity.EntityVars;
import com.x2dev.sis.model.beans.*;
import com.x2dev.sis.model.business.SchoolYearDateRangeLookup;
import com.x2dev.sis.model.business.schedule.ScheduleManager;
import com.x2dev.sis.tools.stateexports.StudentHistoryHelper;
import com.x2dev.sis.tools.stateexports.StudentScheduleSpan;
import com.x2dev.utils.StringUtils;
import com.x2dev.utils.X2BaseException;
import com.x2dev.utils.converters.BooleanAsStringConverter;
import com.x2dev.utils.converters.ConverterFactory;
import com.x2dev.utils.converters.DateAsStringConverter;
import com.x2dev.utils.types.PlainDate;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import org.apache.ojb.broker.query.QueryByCriteria;
import org.apache.ojb.broker.query.ReportQueryByCriteria;

/**
 * Class for district organization export.
 */
public class PAStaffStudentSubtest extends StateReportData {

    /**
     * The Class PAStaffStudentSubtestEntity.
     *
     * The main data source for this export is generated by processing student schedule spans for
     * sections that meet the following criteria:
     * 1) section.schoolCourse.masterType = Class
     * 2) student.[DOE EXCLUDE STD] != true
     * 3) section.[DOE EXCLUDE MST] != true
     * 4) section.schoolCourse.course.[DOE EXCLUDE CRS] != true
     * 5) section is related to a course with a [DOE ALTERNATE] that is contained in the
     * [pssa-keystone-courses] for an assessment definition with a value in [DOE SUBTEST ID] that is
     * a state reference code from the table related to this field
     *
     * The staff assigned to each student schedule span is determined by examining the primary
     * indicator and the teacher role for every Schedule Teacher record for the section. The record
     * is included for the teacher if either the primary flag is true or the teacher role is equal
     * to 'Co-Teach 1' or 'Co-Teach 2'. If no primary teacher or co-teachers are found, the student
     * schedule span is not included.
     *
     * If multiple sections with the same Course[DOE ALTERNATE] are found for the same teacher and
     * student, the records are combined. This feature may be used for sections that are separate by
     * semester.
     *
     * If multiple assessments are mapped to the same section, a separate record is created for each
     * assessment.
     *
     * Students with field [DOE ASSESSMENT PARTICIPATION] equal to 'A' are not processed.
     *
     * If a teacher is found with the co teaching roles, the responsibility for that teacher is
     * determined by examining StudentSchedule.[DOE STF 1 INST WT] or StudentSchedule.[DOE STF 2
     * INST WT]. The primary staff is assigned the instructional weight percentage not assigned to
     * the co-teachers. If there are multiple rows, there are multiple records.
     */
    public static class PAStaffStudentSubtestEntity extends StateReportEntity {

        /**
         * Helper class to store the state report values generated for a particular
         * StudentEnrollment.
         */
        public class EntityKey {
            private String m_staffOid;
            private String m_stateCourseCode;
            private String m_stdOid;

            /**
             * Instantiates a new entity key.
             *
             * @param mstOid String
             * @param mtcOid String
             * @param stdOid String
             */
            public EntityKey(String mstOid, String mtcOid, String stdOid) {
                m_stateCourseCode = mstOid;
                m_staffOid = mtcOid;
                m_stdOid = stdOid;
            }

            /**
             * Equals.
             *
             * @param obj Object
             * @return true, if successful
             * @see java.lang.Object#equals(java.lang.Object)
             */
            @Override
            public boolean equals(Object obj) {

                boolean value = false;

                if (obj instanceof EntityKey) {
                    if (m_stateCourseCode.equals(((EntityKey) obj).getStateCourseCode())
                            && m_staffOid.equals(((EntityKey) obj).getStaffOid())
                            && m_stdOid.equals(((EntityKey) obj).getStdOid())) {
                        value = true;
                    }
                }
                return value;

            }

            /**
             * Hash code.
             *
             * @return int
             * @see java.lang.Object#hashCode()
             */
            @Override
            public int hashCode() {
                return m_stateCourseCode.hashCode() + m_staffOid.hashCode() + m_stdOid.hashCode();
            }

            /**
             * Gets the staff oid.
             *
             * @return the enrollmentCode
             */
            public String getStaffOid() {
                return m_staffOid;
            }

            /**
             * Gets the state course code.
             *
             * @return the mstOid
             */
            public String getStateCourseCode() {
                return m_stateCourseCode;
            }

            /**
             * Gets the std oid.
             *
             * @return the enrollmentCode
             */
            public String getStdOid() {
                return m_stdOid;
            }

        }

        /**
         * The Class EntityVarItem.
         */
        public class EntityVarItem {
            private int m_schedMinutes;
            private int m_sharedRespValue;
            private StudentScheduleSpan m_studentScheduleSpan;
            private ScheduleTeacher m_teacher;
            private int m_totalMinutes;

            /**
             * Instantiates a new entity var item.
             *
             * @param studentScheduleSpan StudentScheduleSpan
             * @param sharedRespValue int
             */
            public EntityVarItem(StudentScheduleSpan studentScheduleSpan, int sharedRespValue) {
                super();
                m_studentScheduleSpan = studentScheduleSpan;
                m_sharedRespValue = sharedRespValue;
            }

            /**
             * Gets the scheduled minutes.
             *
             * @return double
             */
            public double getScheduledMinutes() {
                return m_schedMinutes;
            }

            /**
             * Gets the shared resp value.
             *
             * @return the sharedRespValue
             */
            public int getSharedRespValue() {
                return m_sharedRespValue;
            }

            /**
             * Gets the student schedule span.
             *
             * @return the studentScheduleSpan
             */
            public StudentScheduleSpan getStudentScheduleSpan() {
                return m_studentScheduleSpan;
            }

            /**
             * Gets the teacher.
             *
             * @return Schedule teacher
             */
            public ScheduleTeacher getTeacher() {
                return m_teacher;
            }

            /**
             * Gets the total minutes.
             *
             * @return the minutes
             */
            public double getTotalMinutes() {
                return m_totalMinutes;
            }

            /**
             * Includes date.
             *
             * @param date PlainDate
             * @return true, if successful
             */
            public boolean includesDate(PlainDate date) {
                boolean value = false;
                if (!date.before(m_studentScheduleSpan.getEntryDate()) &&
                        ((m_studentScheduleSpan.getExitChange() == null
                                && !date.after(m_studentScheduleSpan.getExitDate())) ||
                                (m_studentScheduleSpan.getExitChange() != null
                                        && date.before(m_studentScheduleSpan.getExitDate())))) {
                    value = true;
                }
                return value;
            }

            /**
             * Includes date.
             *
             * @param date PlainDate
             * @param sectionOid String
             * @return true, if successful
             */
            public boolean includesDate(PlainDate date, String sectionOid) {
                boolean value = false;
                if (m_studentScheduleSpan.getSection().getOid().equals(sectionOid)) {
                    value = includesDate(date);
                }
                return value;
            }

            /**
             * Sets the scheduled minutes.
             *
             * @param minutes void
             */
            public void setScheduledMinutes(int minutes) {
                m_schedMinutes = minutes;
            }

            /**
             * Sets the teacher.
             *
             * @param teacher void
             */
            public void setTeacher(ScheduleTeacher teacher) {
                m_teacher = teacher;
            }

            /**
             * Sets the total minutes.
             *
             * @param minutes void
             */
            public void setTotalMinutes(int minutes) {
                m_totalMinutes = minutes;
            }
        }

        /**
         * Helper class to store the state report values generated for a particular
         * StudentEnrollment.
         */
        public class EntityVars {
            private AssessmentDefinition m_assessment;
            private String m_courseCode;
            private List<EntityVarItem> m_items;
            private AssessmentDefinition m_pasaAsd;
            private List<StudentScheduleSpan> m_spans;
            private SisStudent m_student;
            private ScheduleTeacher m_teacher;

            /**
             * Instantiates a new entity vars.
             *
             * @param teacher ScheduleTeacher
             * @param student SisStudent
             * @param item EntityVarItem
             * @param pasaAsd AssessmentDefinition
             */
            public EntityVars(ScheduleTeacher teacher, SisStudent student, EntityVarItem item,
                    AssessmentDefinition pasaAsd) {
                m_teacher = teacher;
                // m_section = section;
                m_courseCode = (String) item.getStudentScheduleSpan().getSection().getSchoolCourse().getCourse()
                        .getFieldValueByAlias("DOE ALTERNATE");

                m_student = student;
                m_items = new LinkedList();
                m_items.add(item);
                item.setTeacher(m_teacher);

                m_pasaAsd = pasaAsd;
            }

            /**
             * Instantiates a new entity vars.
             *
             * @param value EntityVars
             */
            public EntityVars(EntityVars value) {
                m_assessment = value.m_assessment;
                m_items = value.m_items;
                m_student = value.m_student;
                m_teacher = value.m_teacher;
                m_pasaAsd = value.m_pasaAsd;
            }

            /**
             * Adds the student schedule span.
             *
             * @param item EntityVarItem
             */
            public void addItem(EntityVarItem item) {
                m_items.add(item);
            }

            /**
             * Equals.
             *
             * @param obj Object
             * @return true, if successful
             * @see java.lang.Object#equals(java.lang.Object)
             */
            @Override
            public boolean equals(Object obj) {

                boolean value = false;

                if (obj instanceof EntityVars) {
                    if (m_courseCode.equals(((EntityVars) obj).getCourseCode())
                            && m_teacher.equals(((EntityVars) obj).getTeacher())
                            && m_student.equals(((EntityVars) obj).getStudent())) {
                        value = true;
                    }
                }
                return value;

            }

            /**
             * Gets the assessment.
             *
             * @return Assessment definition
             */
            public AssessmentDefinition getAssessment() {
                if (isPasaStudent()) {
                    return m_pasaAsd;
                }

                return m_assessment;
            }

            /**
             * Gets the concur enr value.
             *
             * @return the m_concurEnrValue
             */
            public int getConcurEnrValue() {
                double concurrentEnrollment = 0.0;
                for (EntityVarItem item : m_items) {
                    concurrentEnrollment +=
                            (item.getScheduledMinutes() / item.getTotalMinutes()) * determineStdTeacherConcEnr(item);
                }
                return (int) Math.round(concurrentEnrollment > 100.0 ? 100.0 : concurrentEnrollment);
            }

            /**
             * Gets the course code.
             *
             * @return String
             */
            public String getCourseCode() {
                return m_courseCode;
            }

            /**
             * Gets the items.
             *
             * @return List
             */
            public List<EntityVarItem> getItems() {
                return m_items;
            }

            /**
             * Gets the sections.
             *
             * @return the mstOid
             */
            public Set<MasterSchedule> getSections() {
                Set<MasterSchedule> sections = new HashSet();
                for (EntityVarItem item : m_items) {
                    sections.add(item.getStudentScheduleSpan().getSection());
                }
                return sections;
            }

            /**
             * Gets the shared resp value.
             *
             * @return the m_sharedRespValue
             */
            public int getSharedRespValue() {
                if (m_items.size() == 1) {
                    return m_items.iterator().next().getSharedRespValue();
                }
                double sharedRespValue = 0.0;
                double totalRespValue = 0.0;
                for (EntityVarItem item : m_items) {
                    sharedRespValue +=
                            (item.getScheduledMinutes() / item.getTotalMinutes()) * item.getSharedRespValue();
                    totalRespValue +=
                            (item.getScheduledMinutes() / item.getTotalMinutes());
                }
                return (int) Math.round(sharedRespValue / totalRespValue);
            }

            /**
             * Gets the student.
             *
             * @return the enrollmentCode
             */
            public SisStudent getStudent() {
                return m_student;
            }

            /**
             * Gets the student schedule.
             *
             * @return Student schedule
             */
            public StudentSchedule getStudentSchedule() {
                StudentScheduleSpan spanWithSchedule = null;

                for (EntityVarItem item : m_items) {
                    StudentScheduleSpan span = item.getStudentScheduleSpan();
                    if (span.getSchedule() != null) {
                        if (spanWithSchedule == null || span.getExitDate().after(spanWithSchedule.getExitDate())) {
                            spanWithSchedule = span;
                        }

                    }
                }
                return spanWithSchedule != null ? spanWithSchedule.getSchedule() : null;
            }

            /**
             * Gets the spans.
             *
             * @return List
             */
            public List<StudentScheduleSpan> getSpans() {
                List<StudentScheduleSpan> spans = new LinkedList();
                for (EntityVarItem item : m_items) {
                    spans.add(item.getStudentScheduleSpan());
                }
                return spans;
            }

            /**
             * Gets the teacher.
             *
             * @return the enrollmentCode
             */
            public ScheduleTeacher getTeacher() {
                return m_teacher;
            }

            /**
             * Hash code.
             *
             * @return int
             * @see java.lang.Object#hashCode()
             */
            @Override
            public int hashCode() {
                return m_courseCode.hashCode() + m_teacher.getStaffOid().hashCode() + m_student.getOid().hashCode();
            }

            /**
             * Checks if is pasa student.
             *
             * @return true, if is pasa student
             */
            public boolean isPasaStudent() {
                return "A".equals(m_student.getFieldValueByAlias(ALIAS_STUDENT_ASSESSMENT_PARTICIPATION));
            }

            /**
             * Sets the assessment.
             *
             * @param assessment void
             */
            public void setAssessment(AssessmentDefinition assessment) {
                m_assessment = assessment;
            }

            /**
             * To string.
             *
             * @return String
             * @see java.lang.Object#toString()
             */
            @Override
            public String toString() {
                return m_student.getOid() + " " + m_student.getStateId() + " " + m_student.getNameView() + " "
                        + m_courseCode + " " + m_teacher.getStaff().getStateId() + " " + m_teacher.getStaffOid();
            }

            /**
             * Determine the percentage of concurrent enrollment between this teacher and this
             * student.
             * <li>Find the value for this student/teacher by examining the SSC. If this teacher is
             * primary, check the [DOE SSC ADJUSTED ENROLL] field. If the teacher has role
             * 'Co-Teach', check the [DOE SSC ADJUSTED ENROLL 1] field. If the teacher has
             * role 'Co-Teach 2', check the [DOE SSC ADJUSTED ENROLL 2] field.</li>
             * <li>If the value is null or zero, check the MTC record and use the [DOE MTC ADJUSTED
             * ENROLL].</li>
             * <li>If the value is still null or zero, use 100. If the value entered is greater than
             * 100, use 100.</li>
             *
             * @param teacher ScheduleTeacher
             * @param stdSchedule StudentSchedule
             * @param alias String
             * @return int
             */
            private int calculateAdjustedEnrForRole(ScheduleTeacher teacher,
                                                    StudentSchedule stdSchedule,
                                                    String alias) {
                int value = 0;

                try {
                    Number intTempValueMTC = (Number) m_exportData.getPropertyAsJavaType(stdSchedule,
                            m_exportData.translateAliasToJavaName(alias, false));
                    if (intTempValueMTC == null || intTempValueMTC.intValue() == 0
                            || intTempValueMTC.intValue() > 100) {
                        value = 100;
                    } else {
                        value = intTempValueMTC.intValue();
                    }
                } catch (X2BaseException e1) {
                    // don't update value on parse error
                }
                return value;
            }

            /**
             * Determine the percentage of concurrent enrollment between this teacher and this
             * student.
             *
             * @param item EntityVars
             * @return int
             */
            private int determineStdTeacherConcEnr(EntityVarItem item) {
                int value = 100;
                StudentSchedule stdSchedule = item.getStudentScheduleSpan().getSchedule();
                if (stdSchedule != null && item.getTeacher() != null) {
                    if (item.getTeacher().getPrimaryTeacherIndicator()) {
                        value = calculateAdjustedEnrForRole(item.getTeacher(), stdSchedule, ALIAS_SSC_ADJUSTED_ENR);
                    }
                    if (MTC_ROLE_CO_TEACH_1.equals(item.getTeacher().getRole())) {
                        value = calculateAdjustedEnrForRole(item.getTeacher(), stdSchedule, ALIAS_SSC_ADJUSTED_ENR_1);

                    }
                    if (MTC_ROLE_CO_TEACH_2.equals(item.getTeacher().getRole())) {
                        value = calculateAdjustedEnrForRole(item.getTeacher(), stdSchedule, ALIAS_SSC_ADJUSTED_ENR_2);
                    }
                }

                return value;
            }

        }

        protected List<EntityVars> m_entVars;
        protected PAStaffStudentSubtest m_exportData;

        /**
         * Instantiates a new PA staff student subtest entity.
         */
        public PAStaffStudentSubtestEntity() {
            // Public no argument constructor for dynamic instantiation.
        }

        /**
         * Return the vars for the current row.
         *
         * @return Entity vars
         */
        public EntityVars getCurrentVars() {
            return m_entVars.get(getCurrentRow());
        }

        /**
         * Generate a display name to print on the validation report for the entity.
         *
         * @return String
         * @see com.follett.fsc.core.k12.tools.stateexports.StateReportEntity#getEntityName()
         */
        @Override
        public String getEntityName() {
            EntityVars vars = getCurrentVars();
            SisStudent student = (SisStudent) getBean();
            String name = null;
            try {
                name = student.getNameView() + " [LASID: " + student.getLocalId() + ", SASID: "
                        + student.getStateId() + ", School ID: " + student.getSchool().getSchoolId()
                        + ", STATE COURSE CODE: "
                        + vars.getCourseCode() + ", TEACHER: " + vars.getTeacher().getOid() + "] ";
            } catch (NullPointerException e) {
                AppGlobals.getLog().log(Level.SEVERE, e.getLocalizedMessage(), e);
            }

            return name;
        }

        /**
         * Uses student schedule spans and teacher list to determine the export rows.
         *
         * @param data StateReportData
         * @param bean X2BaseBean
         * @throws X2BaseException exception
         * @see
         *      com.follett.fsc.core.k12.tools.stateexports.StateReportEntity#intitialize(com.follett.fsc
         *      .core.k12.tools.stateexports.StateReportData,
         *      com.follett.fsc.core.k12.beans.X2BaseBean)
         */
        @Override
        public void intitialize(StateReportData data, X2BaseBean bean) throws X2BaseException {
            super.intitialize(data, bean);
            m_exportData = (PAStaffStudentSubtest) data;

            SisStudent student = (SisStudent) getBean();

            boolean studentWasActive = true;
            if (!StudentManager.isActiveStudent(data.getOrganization(), student.getEnrollmentStatus())) {
                StudentEnrollment withdrawal = m_exportData.getStdHelper().getEnrollmentForDate(student.getOid(),
                        new PlainDate(), StudentEnrollment.WITHDRAWAL);
                PlainDate schoolYearStart =
                        m_exportData.m_schoolYearLookup.getStartDate(student.getSchoolOid(), student.getCalendarCode());
                studentWasActive = withdrawal.getEnrollmentDate() != null
                        && !withdrawal.getEnrollmentDate().before(schoolYearStart);
            }

            Map<EntityKey, EntityVars> mapEntVars = new HashMap();
            m_entVars = new ArrayList(mapEntVars.values().size());

            if (studentWasActive) {
                Collection<StudentScheduleSpan> stdSchSpans =
                        m_exportData.getStdHelper().getStudentScheduleSpans(student);

                for (StudentScheduleSpan stdSchSpan : stdSchSpans) {
                    MasterSchedule mst = stdSchSpan.getSection();
                    if (mst != null) {
                        determineSharedInstResp(mapEntVars, mst, student, stdSchSpan);
                    }
                }

                for (EntityVars value : mapEntVars.values()) {
                    List<AssessmentDefinition> asds = m_exportData.getAssessments(value);
                    if (asds != null && !asds.isEmpty()) {
                        boolean makeCopy = false;
                        for (AssessmentDefinition asd : asds) {
                            String subTestId = (String) asd.getFieldValueByBeanPath(m_exportData.m_fieldASDSubTestId);
                            if (!value.isPasaStudent() && matchingGrade(subTestId, student.getGradeLevel())) {
                                EntityVars copy = makeCopy ? new EntityVars(value) : value;
                                copy.setAssessment(asd);
                                determineAdjustedConcurrentEnrollment(value);
                                if (value.getConcurEnrValue() > 0) {
                                    m_entVars.add(copy);
                                    makeCopy = true;
                                }
                            }
                        }
                    }
                }
            }

            setRowCount(m_entVars.size());
        }

        /**
         * @param subTestId
         * @param gradeLevel
         * @return boolean
         */
        private boolean matchingGrade(String subTestId, String gradeLevel) {
            char lastChar = subTestId.charAt(subTestId.length() - 1);
            if (Character.isDigit(lastChar)) {
                int subTestInt = Integer.parseInt(lastChar + "");
                if (subTestInt != m_exportData.m_gradeLevels.get(gradeLevel).intValue()) {
                    return false;
                }
            }

            return true;
        }

        /**
         * Add a new schedule span or create a new entitiy var.
         *
         * @param map Map<EntityKey,EntityVars>
         * @param mst MasterSchedule
         * @param teacher ScheduleTeacher
         * @param student SisStudent
         * @param stdScheduleSpan StudentScheduleSpan
         * @param respValue int
         */
        private void addEntityVar(Map<EntityKey, EntityVars> map,
                                  MasterSchedule mst,
                                  ScheduleTeacher teacher,
                                  SisStudent student,
                                  StudentScheduleSpan stdScheduleSpan,
                                  int respValue) {
            String courseCode = (String) mst.getSchoolCourse().getCourse().getFieldValueByAlias("DOE ALTERNATE");

            if (!StringUtils.isEmpty(courseCode)) {
                EntityKey key = new EntityKey(courseCode, teacher.getStaffOid(), student.getOid());
                EntityVars value = map.get(key);
                if (value == null) {
                    map.put(key,
                            new EntityVars(teacher, student, new EntityVarItem(stdScheduleSpan, respValue),
                                    ((PAStaffStudentSubtest) getData()).m_pasaAsd));
                } else {
                    value.addItem(new EntityVarItem(stdScheduleSpan, respValue));
                }
            }

        }

        /**
         * Calculate final value for Shared Instructional Responsibility.
         *
         * @param coTeachResp String
         * @return int
         */
        private int calculateRespValue(String coTeachResp) {
            int coTechRespValue = 0;
            if (coTeachResp != null) {
                try {
                    int tempValue1 = (int) Double.parseDouble(coTeachResp);
                    if (tempValue1 > 100) {
                        coTechRespValue = 100;
                    } else if (tempValue1 > 0) {
                        coTechRespValue = tempValue1;
                    }
                } catch (NumberFormatException e) {
                    return coTechRespValue;
                }
            }

            return coTechRespValue;
        }

        /**
         * Determining Adjusted Concurrent Enrollment.
         *
         * @param value EntityVars
         * @return int
         */
        private void determineAdjustedConcurrentEnrollment(EntityVars value) {
            try {
                PlainDate assessmentDate = m_exportData.getAssessmentDate(value.getAssessment());

                for (EntityVarItem item : value.getItems()) {
                    MasterSchedule section = item.getStudentScheduleSpan().getSection();
                    int currentSectionMinutes = 0;

                    int currentStudentScheduledMinutes = 0;

                    Collection<SisSchoolCalendarDate> dates = m_exportData.getSectionDates(section);

                    int daysInSection = 0;

                    if (dates != null) {
                        for (SisSchoolCalendarDate date : dates) {
                            if (assessmentDate != null && assessmentDate.before(date.getDate())) {
                                // skip dates after assessment date
                                continue;
                            }
                            int dailyScheduledMinutes = 0;
                            ScheduleBell bell = date.getBellSchedule();
                            if (bell != null) {
                                Collection<SchedulePeriod> periods = m_exportData.getSectionPeriods(section, date);
                                if (periods != null && periods.size() > 0) {
                                    for (SchedulePeriod period : periods) {
                                        int minutes = m_exportData.getPeriodTime(bell, period);
                                        dailyScheduledMinutes += minutes;
                                    }
                                }
                            }
                            if (item.includesDate(date.getDate(), section.getOid())) {
                                currentStudentScheduledMinutes += dailyScheduledMinutes;
                                daysInSection++;
                            }

                            if (dailyScheduledMinutes > 0) {
                                currentSectionMinutes += dailyScheduledMinutes;
                            }
                        }

                        if (currentSectionMinutes > 0) {
                            if (daysInSection == 1) {
                                currentStudentScheduledMinutes = 0;
                            }

                            if (currentStudentScheduledMinutes > 0) {
                                item.setScheduledMinutes(currentStudentScheduledMinutes);
                                item.setTotalMinutes(currentSectionMinutes);
                            }
                        }
                    }
                }
            } catch (NullPointerException npe) {
                throw new RuntimeException("NullPointerException " + value.toString());
            }
        }

        /**
         * Determining Shared Instructional Responsibility.
         *
         * @param map Map<EntityKey,EntityVars>
         * @param mst MasterSchedule
         * @param student SisStudent
         * @param stdScheduleSpan StudentScheduleSpan
         */
        private void determineSharedInstResp(Map<EntityKey, EntityVars> map,
                                             MasterSchedule mst,
                                             SisStudent student,
                                             StudentScheduleSpan stdScheduleSpan) {
            SchoolCourse schoolCourse = mst.getSchoolCourse();
            Course course = schoolCourse.getCourse();

            String pssaExclude = (String) course.getFieldValueByAlias(ALIAS_PSSA_EXCLUDE);

            if (!BooleanAsStringConverter.TRUE.equals(pssaExclude)) {
                int primaryTeacherValue = 0;
                Collection<ScheduleTeacher> teachers = m_exportData.getTeachersMap().get(mst.getOid());
                if (teachers != null && !teachers.isEmpty()) {
                    StudentSchedule schedule = stdScheduleSpan.getSchedule();
                    int coTech1RespValue = 0;
                    int coTech2RespValue = 0;
                    for (ScheduleTeacher teacher : teachers) {
                        if (!teacher.getPrimaryTeacherIndicator()) {
                            if (MTC_ROLE_CO_TEACH_1.equals(teacher.getRole())) {
                                int respValue = 0;
                                if (schedule != null) {
                                    String coTeach1Resp =
                                            (String) schedule.getFieldValueByAlias(ALIAS_SSC_INST_RESP_1);
                                    respValue = calculateRespValue(coTeach1Resp);
                                }
                                if (respValue == 0) {
                                    String coTeach1Resp =
                                            (String) teacher.getFieldValueByAlias(ALIAS_MTC_INSTRUCTIONAL_WEIGHT);
                                    respValue = calculateRespValue(coTeach1Resp);
                                }
                                if (respValue > 0) {
                                    coTech1RespValue += respValue;
                                    addEntityVar(map, mst, teacher, student, stdScheduleSpan, respValue);
                                }
                            }
                            if (MTC_ROLE_CO_TEACH_2.equals(teacher.getRole())) {
                                int respValue = 0;
                                if (schedule != null) {
                                    String coTeach2Resp =
                                            (String) schedule.getFieldValueByAlias(ALIAS_SSC_INST_RESP_2);
                                    respValue = calculateRespValue(coTeach2Resp);
                                }
                                if (respValue == 0) {
                                    String coTeach2Resp =
                                            (String) teacher.getFieldValueByAlias(ALIAS_MTC_INSTRUCTIONAL_WEIGHT);
                                    respValue = calculateRespValue(coTeach2Resp);
                                }
                                if (respValue > 0) {
                                    coTech2RespValue += respValue;
                                    addEntityVar(map, mst, teacher, student, stdScheduleSpan, respValue);
                                }
                            }
                        }
                    }
                    for (ScheduleTeacher teacher : teachers) {
                        if (teacher.getPrimaryTeacherIndicator()) {
                            primaryTeacherValue = 100 - coTech1RespValue - coTech2RespValue;
                            addEntityVar(map, mst, teacher, student, stdScheduleSpan, primaryTeacherValue);
                        }
                    }
                }
            }
        }

    }

    /**
     * Retriever used to return value of the export fields.
     *
     * STAFF DISTRICT CODE - The organization id of organization 1 for the teacher on the schedule
     * teacher.
     *
     * STAFF ID - The state id of the teacher on the schedule teacher
     *
     * STD DISTR CODE - The organization id of organization 1 for the student
     *
     * STUDENT ID - The state id of the student
     *
     * SCHOOL YEAR DATE - The current context end date formatted with 'yyyy-06-30'
     *
     * ASSESSM DISTR CODE - The fixed value 999999999
     *
     * TEST DESCRIPTION - The name of the associated assessment definition
     *
     * ASSESSM SCHOOL YEAR - The current context end date formatted with 'yyyy-06-30'
     *
     * SUBTEST IDENTIFIER - The value from the assessment definition field [DOE SUBTEST ID]
     *
     * PERCNT OF SHARED - When processing a section, the schedule teachers are examined to determine
     * the primary teacher, co-teacher 1 and co-teacher 2. Co-teachers are determined by examining
     * the role of none primary teachers to determine if they have the role values 'Co-Teach 1' or
     * 'Co-Teach 2'. For the co-teacher records, this value is determined by examining the
     * StudentSchedule.[DOE STF 1 INST WT] or StudentSchedule.[DOE STF 2 INST WT] fields. For the
     * primary teacher, the value is 100 minus the co-teacher values.
     *
     * PERCNT OF CONC ENR - The unadjusted concurrent enrollment is calculated by first calculating
     * the total number of scheduled minutes for the section. Then the total number of scheduled
     * minutes the student is enrolled in the class is calculated based on the date span in the
     * student schedule span. The unadjusted value is student minutes divided by section minutes. If
     * the student schedule span is still associated with a student schedule, an adjustment to this
     * value can be made based on the student schedule fields [DOE SSC ADJUSTED ENROLL], [DOE SSC
     * ADJUSTED ENROLL 1], [DOE SSC ADJUSTED ENROLL 2] for primary, co-teacher1 and co-teacher2. If
     * an adjustment is found, the unadjusted value is multiplied by the adjustment.
     *
     * NOTE: Adjustments are not possible after the student schedule is deleted. There are no
     * similar
     * aliases in student schedule change. * RELATIONSHIP LOCAT - The [DOE SCHOOL STATE ID] field
     * from the school associated with the
     * section for the schedule span.
     *
     */
    public class RetrieveSubtestInfo implements FieldRetriever {
        /**
         * Calculation parameters
         */
        private static final String CALC_PARAM_ASSESSMENT_CODE = "ASSESSMENT CODE";
        private static final String CALC_PARAM_ASSESSMENT_DESC = "ASSESSMENT DESC";
        private static final String CALC_PARAM_PERCNT_OF_CONC_ENR = "PERCNT OF CONC ENR";
        private static final String CALC_PARAM_PERCNT_OF_SHARED = "PERCNT OF SHARED";
        private static final String CALC_PARAM_REL_LOCATION = "REL LOCATION";
        private static final String CALC_PARAM_SKL_YEAR = "SKL YEAR";
        private static final String CALC_PARAM_STD_DISTR_CODE = "STD DISTR CODE";
        private static final String CALC_PARAM_STD_ID = "STD ID";
        private static final String CALC_PARAM_STF_DISTR_CODE = "STF DISTR CODE";
        private static final String CALC_PARAM_STF_ID = "STF ID";
        private static final String CALC_PARAM_SUBTEST_ID = "SUBTEST ID";

        private SimpleDateFormat formatter = new SimpleDateFormat("yyyy-06-30");

        /**
         * Gets the field value.
         *
         * @param data StateReportData
         * @param entity StateReportEntity
         * @param field FieldDefinition
         * @return Object
         * @throws X2BaseException exception
         * @see com.follett.fsc.core.k12.tools.stateexports.FieldRetriever#getFieldValue(com.follett.fsc.core.k12.tools.stateexports.StateReportData,
         *      com.follett.fsc.core.k12.tools.stateexports.StateReportEntity,
         *      com.follett.fsc.core.k12.tools.stateexports.FieldDefinition)
         */
        @Override
        public Object getFieldValue(StateReportData data, StateReportEntity entity, FieldDefinition field)
                throws X2BaseException {
            String value = "";
            PAStaffStudentSubtestEntity stfSubtestEntity = (PAStaffStudentSubtestEntity) entity;
            PAStaffStudentSubtestEntity.EntityVars vars = stfSubtestEntity.getCurrentVars();

            String parameter = (String) field.getParameter();

            if (CALC_PARAM_STF_DISTR_CODE.equals(parameter)) {
                ScheduleTeacher mtc = vars.getTeacher();
                value = mtc != null ? mtc.getStaff().getOrganization1().getId() : "";
            } else if (CALC_PARAM_STF_ID.equals(parameter)) {
                ScheduleTeacher mtc = vars.getTeacher();
                value = mtc != null ? mtc.getStaff().getStateId() : "";
            } else if (CALC_PARAM_STD_DISTR_CODE.equals(parameter)) {
                SisStudent std = vars.getStudent();
                value = std != null ? std.getOrganization1().getId() : "";
            } else if (CALC_PARAM_STD_ID.equals(parameter)) {
                SisStudent std = vars.getStudent();
                value = std != null ? std.getStateId() : "";
            } else if (CALC_PARAM_SKL_YEAR.equals(parameter)) {
                PlainDate date = getOrganization().getCurrentContext().getEndDate();
                Calendar cal = Calendar.getInstance();
                cal.setTime(date);
                value = formatter.format(cal.getTime());
            } else if (CALC_PARAM_ASSESSMENT_CODE.equals(parameter)) {
                AssessmentDefinition asd = vars.getAssessment();
                value = asd != null ? asd.getOrganization1().getId() : "";
            } else if (CALC_PARAM_ASSESSMENT_DESC.equals(parameter)) {
                AssessmentDefinition asd = vars.getAssessment();
                value = asd != null ? asd.getName() : "";
            } else if (CALC_PARAM_SUBTEST_ID.equals(parameter)) {
                AssessmentDefinition asd = vars.getAssessment();
                if (asd == null) {
                    value = "";
                } else {
                    value = data.lookupStateValue(AssessmentDefinition.class, m_fieldASDSubTestId,
                            (String) asd.getFieldValueByBeanPath(stfSubtestEntity.m_exportData.m_fieldASDSubTestId));
                }
                value = asd != null
                        ? (String) asd.getFieldValueByBeanPath(stfSubtestEntity.m_exportData.m_fieldASDSubTestId)
                        : "";
            } else if (CALC_PARAM_PERCNT_OF_SHARED.equals(parameter)) {
                value = vars != null ? Integer.toString(vars.getSharedRespValue()) : "";
            } else if (CALC_PARAM_PERCNT_OF_CONC_ENR.equals(parameter)) {
                value = vars != null ? Integer.toString(vars.getConcurEnrValue()) : "";
            } else if (CALC_PARAM_REL_LOCATION.equals(parameter)) {
                ScheduleTeacher mtc = vars.getTeacher();
                if (mtc != null && mtc.getSection() != null && mtc.getSection().getSchedule() != null
                        && mtc.getSection().getSchedule().getSchool() != null) {
                    value = (String) mtc.getSection().getSchedule().getSchool()
                            .getFieldValueByAlias(ALIAS_SKL_ID_STATE);
                }
            }
            return value;
        }

    }

    /**
     * Aliases
     */
    private static final String ALIAS_ASD_PSSA_KEYSTONE_COURSES = "pssa-keystone-courses";
    private static final String ALIAS_ASD_SUBTEST_ID = "DOE SUBTEST ID";
    private static final String ALIAS_ASD_WINDOW_OPEN = "all-asd-AssessmentWindowOpen";
    private static final String ALIAS_CRS_ALTERNATE = "DOE ALTERNATE";
    private static final String ALIAS_MTC_INSTRUCTIONAL_WEIGHT = "all-mtc-StaffInstructionalWeight";
    private static final String ALIAS_SKL_ID_STATE = "DOE SCHOOL STATE ID";
    private static final String ALIAS_SSC_INST_RESP_1 = "DOE STF 1 INST WT";
    private static final String ALIAS_SSC_INST_RESP_2 = "DOE STF 2 INST WT";
    private static final String ALIAS_SSC_ADJUSTED_ENR = "DOE SSC ADJUSTED ENROLL";
    private static final String ALIAS_SSC_ADJUSTED_ENR_1 = "DOE SSC ADJUSTED ENROLL 1";
    private static final String ALIAS_SSC_ADJUSTED_ENR_2 = "DOE SSC ADJUSTED ENROLL 2";

    private static final String ALIAS_ASSESSMENT_COURSE_TERMS = "DOE ASSESSMENT COURSE TERMS";
    private static final String ALIAS_PSSA_EXCLUDE = "DOE PSSA EXCLUDE";
    private static final String ALIAS_STUDENT_ASSESSMENT_PARTICIPATION = "DOE ASSESSMENT PARTICIPATION";
    private static final String ALIAS_ASSESSMENT_SCHOOL_LEVEL = "DOE ASSESSMENT SCHOOL LEVEL";

    /**
     * Retrievers Ids
     */
    private static final String CALC_ID_SUBTEST_INFO = "SUBTEST INFO ID";

    /**
     * Constants
     */
    private static final String MTC_ROLE_CO_TEACH_1 = "Co-Teach 1";
    private static final String MTC_ROLE_CO_TEACH_2 = "Co-Teach 2";
    private static final String PASA_ASSESSMENT_ID = "PASA";

    protected AssessmentDefinition m_pasaAsd = null;
    protected SchoolYearDateRangeLookup m_schoolYearLookup = null;

    private Map<String, List<AssessmentDefinition>> m_assessmentMap = new HashMap();
    private Map<String, Collection<ScheduleBellPeriod>> m_bellPeriods = new HashMap();
    private Set<Course> m_courses;
    private DateAsStringConverter m_dateConverter;
    private SimpleDateFormat m_dateIndexFormat = new SimpleDateFormat("u");

    /**
     * Fields
     */
    private String m_fieldASDKeystoneCourses;
    private String m_fieldASDSubTestId;
    private String m_fieldCRSAlternative;

    private StudentHistoryHelper m_helper;
    private Map<String, Collection<ScheduleDay>> m_scheduleDays = new HashMap();
    private ScheduleManager m_scheduleManager;
    private Map<String, SchedulePeriod> m_schedulePeriods = new HashMap();
    private Map<String, Collection<ScheduleTermDate>> m_scheduleTermDates = new HashMap();
    private Map<String, ScheduleTerm> m_scheduleTerms = new HashMap();
    private Map<String, String> m_sectionCalendarCodes = new HashMap();
    private Map<String, Map<String, Collection<SisSchoolCalendarDate>>> m_sectionDates = new HashMap();
    private Map<String, Collection<MasterSchedule>> m_sectionMap;
    private Map<String, Set<SchedulePeriod>> m_sectionTermDayPeriods = new HashMap();
    private Map<String, Collection<ScheduleTerm>> m_sectionTermsMap = new HashMap();
    private Map<String, Collection<ScheduleTeacher>> m_teachersMap;
    private Map<String, Integer> m_gradeLevels;

    /**
     * Gets the section map.
     *
     * @return the m_sectionMap
     */
    public Map<String, Collection<MasterSchedule>> getSectionMap() {
        return m_sectionMap;
    }

    /**
     * Gets the std helper.
     *
     * @return the m_helper
     */
    public StudentHistoryHelper getStdHelper() {
        return m_helper;
    }

    /**
     * Gets the teachers map.
     *
     * @return the m_teachersMap
     */
    public Map<String, Collection<ScheduleTeacher>> getTeachersMap() {
        return m_teachersMap;
    }

    /**
     * Initialize the data module. Initialize necessary working resources. Define query for students
     * to load. Define
     * list of field definitions for the export.
     *
     * @see com.follett.fsc.core.k12.tools.stateexports.StateReportData#initialize(java.util.Map,
     *      com.follett.fsc.core.k12.business.X2Broker)
     */
    @Override
    public void initialize() {
        m_scheduleManager = new ScheduleManager(getBroker());
        initializeFields();
        loadGradeLevelRefMap();
        if (getSetupErrors().isEmpty()) {
            initializeCourseMap();
            initializeTeachersAndSectionMaps();
        }

        // Load the PASA assessment definition, which is used in place of the PSSA if the student's
        // assessment participation code is 'A'
        if (getSetupErrors().isEmpty()) {
            X2Criteria criteria = new X2Criteria();
            criteria.addEqualTo(AssessmentDefinition.COL_ID, PASA_ASSESSMENT_ID);
            BeanQuery beanQuery = new BeanQuery(AssessmentDefinition.class, criteria);
            m_pasaAsd = (AssessmentDefinition) getBroker().getBeanByQuery(beanQuery);

            m_schoolYearLookup = new SchoolYearDateRangeLookup(getOrganization().getCurrentContext(),
                    getOrganization().getOid(), getBroker());
        }

        if (getSetupErrors().isEmpty()) {
            m_helper = new StudentHistoryHelper(this);
            m_helper.setStudentSelectionMode(StudentHistoryHelper.MODE_STUDENT_ACTIVE_ANY_TIME);
            m_helper.setStudentSelectionMode(StudentHistoryHelper.MODE_SCHEDULE_SPANS);

            m_helper.getStudentScheduleCriteria().addIn(StudentSchedule.COL_SECTION_OID, m_sectionMap.keySet());
            m_helper.getStudentScheduleChangeCriteria().addIn(StudentScheduleChange.COL_MASTER_SCHEDULE_OID,
                    m_sectionMap.keySet());

            setQuery(m_helper.getStudentQuery(false));
            setEntityClass(PAStaffStudentSubtestEntity.class);

            HashMap calcs = new HashMap<String, FieldRetriever>();
            calcs.put(CALC_ID_SUBTEST_INFO, new RetrieveSubtestInfo());
            super.addCalcs(calcs);

            HashMap<String, FieldValidator> validators = new HashMap<String, FieldValidator>();
            super.addValidators(validators);
        }

    }

    /**
     * Gets the assessment date.
     *
     * @param assessment AssessmentDefinition
     * @return Plain date
     */
    protected PlainDate getAssessmentDate(AssessmentDefinition assessment) {
        String dateString = (String) assessment.getFieldValueByAlias(ALIAS_ASD_WINDOW_OPEN);
        if (m_dateConverter == null) {
            m_dateConverter = (DateAsStringConverter) ConverterFactory.getConverterForClass(PlainDate.class.getName(),
                    Locale.getDefault(), true);
        }

        return (PlainDate) m_dateConverter.parseSystemString(dateString);
    }

    /**
     * Get the assessments for a section.
     *
     * @param entityVars EntityVars
     * @return List
     */
    protected List<AssessmentDefinition> getAssessments(EntityVars entityVars) {
        List<AssessmentDefinition> values = new LinkedList();


        // Use the section from schedule span with an active student schedule. If there are none
        // then take the latest section scheduled

        MasterSchedule section = null;

        StudentSchedule studentSchedule = entityVars.getStudentSchedule();
        if (studentSchedule != null) {
            section = studentSchedule.getSection();
        } else {
            PlainDate currentExitDate = null;

            for (StudentScheduleSpan span : entityVars.getSpans()) {
                if (currentExitDate == null || span.getExitDate().after(currentExitDate)) {
                    section = span.getSection();
                }
            }
        }

        if (section != null) {
            if (section.getSchoolCourse() != null) {
                List<AssessmentDefinition> list = m_assessmentMap.get(section.getSchoolCourse().getCourseOid());
                for (AssessmentDefinition asd : list) {
                    String schoolLevel = (String) asd.getFieldValueByAlias(ALIAS_ASSESSMENT_SCHOOL_LEVEL);

                    if (StringUtils.isEmpty(schoolLevel)
                            || schoolLevel.equals(entityVars.getStudent().getSchool().getSchoolLevelCode())) {
                        String terms = (String) asd.getFieldValueByAlias(ALIAS_ASSESSMENT_COURSE_TERMS);
                        if (!StringUtils.isEmpty(terms)) {
                            List<String> termSet = StringUtils.convertDelimitedStringToList(terms, ",", true);
                            if (termSet.isEmpty() || termSet.contains(section.getScheduleTerm().getCode())) {
                                values.add(asd);
                            }
                        } else {
                            values.add(asd);
                        }
                    }
                }
            }
        }

        return values;
    }

    /**
     * Get the day of week index for a date.
     *
     * @param date PlainDate
     * @return int
     */
    protected int getDateIndex(PlainDate date) {
        String index = m_dateIndexFormat.format(date);
        return Integer.parseInt(index);
    }

    /**
     * Calculate the duration in minutes for a particular period.
     *
     * @param bell ScheduleBell
     * @param per SchedulePeriod
     * @return int
     */
    protected int getPeriodTime(ScheduleBell bell, SchedulePeriod per) {
        Collection<ScheduleBellPeriod> bellPeriods = m_bellPeriods.get(bell.getOid());
        if (bellPeriods == null) {
            bellPeriods = bell.getScheduleBellPeriods();
            m_bellPeriods.put(bell.getOid(), bellPeriods);
        }
        if (bellPeriods != null) {
            for (ScheduleBellPeriod bpe : bellPeriods) {
                if (bpe.getSchedulePeriodOid() != null && bpe.getSchedulePeriodOid().equals(per.getOid()) &&
                        bpe.getStartTime() != null && bpe.getEndTime() != null) {
                    return (int) (bpe.getEndTime().getTimeInMinutes() - bpe.getStartTime().getTimeInMinutes());
                }
            }
        }
        return 0;
    }

    /**
     * Get the schedule term.
     *
     * @param oid String
     * @return Schedule term
     */
    protected ScheduleTerm getScheduleTerm(String oid) {
        ScheduleTerm term = null;
        if (m_scheduleTerms.containsKey(oid)) {
            term = m_scheduleTerms.get(oid);
        } else {
            term = (ScheduleTerm) getBroker().getBeanByOid(ScheduleTerm.class, oid);
            m_scheduleTerms.put(oid, term);
        }
        return term;
    }

    /**
     * Get the schedule term dates.
     *
     * @param oid String
     * @return Collection<ScheduleTermDate>
     */
    protected Collection<ScheduleTermDate> getScheduleTermDates(String oid) {
        Collection<ScheduleTermDate> dates = null;
        if (m_scheduleTermDates.containsKey(oid)) {
            dates = m_scheduleTermDates.get(oid);
        } else {
            ScheduleTerm term = getScheduleTerm(oid);
            dates = term.getScheduleTermDates();
            m_scheduleTermDates.put(oid, dates);
        }
        return dates;
    }

    /**
     * Get a collection of in session calendar dates for a particular section.
     *
     * @param section MasterSchedule
     * @return Collection<SisSchoolCalendarDate>
     */
    protected Collection<SisSchoolCalendarDate> getSectionDates(MasterSchedule section) {
        String calendarCode = m_sectionCalendarCodes.get(section.getOid());
        if (calendarCode == null) {
            calendarCode = m_scheduleManager.getMostCommonCalendar(section.getSchedule(), Arrays.asList(section));
            m_sectionCalendarCodes.put(section.getOid(), calendarCode);
        }
        String key =
                section.getSchedule().getDistrictContextOid() + section.getSchedule().getSchoolOid() + calendarCode;
        Map<String, Collection<SisSchoolCalendarDate>> termDates = m_sectionDates.get(key);
        if (termDates == null) {
            termDates = new HashMap<String, Collection<SisSchoolCalendarDate>>();
            m_sectionDates.put(key, termDates);

            X2Criteria criteriaDates = new X2Criteria();
            criteriaDates.addEqualTo(SisSchoolCalendarDate.REL_SCHOOL_CALENDAR + PATH_DELIMITER +
                    SchoolCalendar.COL_DISTRICT_CONTEXT_OID, section.getSchedule().getDistrictContextOid());
            criteriaDates.addEqualTo(SisSchoolCalendarDate.REL_SCHOOL_CALENDAR + PATH_DELIMITER +
                    SchoolCalendar.COL_SCHOOL_OID, section.getSchedule().getSchoolOid());
            criteriaDates.addEqualTo(SisSchoolCalendarDate.REL_SCHOOL_CALENDAR + PATH_DELIMITER +
                    SchoolCalendar.COL_CALENDAR_ID, calendarCode);
            criteriaDates.addEqualTo(SisSchoolCalendarDate.COL_IN_SESSION_INDICATOR, Boolean.TRUE);

            QueryByCriteria queryDates = new QueryByCriteria(SisSchoolCalendarDate.class, criteriaDates);
            queryDates.addOrderBy(SisSchoolCalendarDate.COL_DATE, true);

            Collection<SisSchoolCalendarDate> dates = getBroker().getCollectionByQuery(queryDates);

            X2Criteria criteria = new X2Criteria();
            criteria.addEqualTo(ScheduleTermDate.REL_SCHEDULE_TERM + PATH_DELIMITER +
                    ScheduleTerm.COL_SCHEDULE_OID, section.getScheduleOid());

            QueryByCriteria query = new QueryByCriteria(ScheduleTermDate.class, criteria);
            Map<String, Collection<ScheduleTermDate>> terms = getBroker().getGroupedCollectionByQuery(query,
                    ScheduleTermDate.COL_SCHEDULE_TERM_OID,
                    32);

            for (String termOid : terms.keySet()) {
                Set<SisSchoolCalendarDate> csdSet = new HashSet<SisSchoolCalendarDate>();
                for (ScheduleTermDate tmd : terms.get(termOid)) {
                    for (SisSchoolCalendarDate csd : dates) {

                        if (tmd.getStartDate() != null && tmd.getEndDate() != null &&
                                !csd.getDate().before(tmd.getStartDate()) && !csd.getDate().after(tmd.getEndDate())) {
                            csdSet.add(csd);
                        }
                    }
                }
                termDates.put(termOid, csdSet);
            }
        }
        return termDates.get(section.getScheduleTermOid());
    }

    /**
     * Get the schedule periods for a particular section on a particular day.
     *
     * @param section MasterSchedule
     * @param csd SisSchoolCalendarDate
     * @return Collection<SchedulePeriod>
     */
    protected Collection<SchedulePeriod> getSectionPeriods(MasterSchedule section, SisSchoolCalendarDate csd) {
        Collection<SchedulePeriod> periods = null;
        Collection<ScheduleTerm> terms = m_sectionTermsMap.get(section.getOid());
        if (terms != null) {
            for (ScheduleTerm trm : terms) {
                for (ScheduleTermDate tmd : getScheduleTermDates(trm.getOid())) {
                    if (!csd.getDate().before(tmd.getStartDate()) && !csd.getDate().after(tmd.getEndDate())) {
                        String key = section.getOid() + tmd.getScheduleTermOid() +
                                getScheduleDayOid(section.getSchedule(), csd.getScheduleDayNumber());
                        periods = m_sectionTermDayPeriods.get(key);
                        break;
                    }
                }
                if (periods != null) {
                    break;
                }
            }
        }
        return periods;
    }

    /**
     * Return all alternate courses in the current context year keyed on state code.
     *
     * @return Map keyed on state code
     */
    private Map<String, Collection<Course>> getAlternateCoursesMap() {
        X2Criteria criteria = new X2Criteria();
        criteria.addEqualTo(Course.COL_DISTRICT_CONTEXT_OID, getOrganization().getCurrentContextOid());
        criteria.addNotEmpty(m_fieldCRSAlternative, getBroker().getPersistenceKey());

        QueryByCriteria crsQuery = new QueryByCriteria(Course.class, criteria);

        return getBroker().getGroupedCollectionByQuery(crsQuery, m_fieldCRSAlternative, 1024);
    }

    /**
     * Get ASD records where the field with alias [DOE SUBTEST ID] is not empty and the
     * field with alias
     * [pssa-keystone-courses] is not empty.
     *
     * @return Assessment Definition collection
     */
    private Collection<AssessmentDefinition> getASDRecords() {
        Set<String> subTestCodes = new HashSet();

        DataDictionaryField field = getDataDictionary().findDataDictionaryField(AssessmentDefinition.class.getName(),
                m_fieldASDSubTestId);

        if (field != null && field.getReferenceTableOid() != null) {
            Map<String, ReferenceCode> codes = getReferenceCodes(field.getReferenceTableOid());

            for (String code : codes.keySet()) {
                ReferenceCode refCode = codes.get(code);
                if (!StringUtils.isEmpty(refCode.getStateCode())) {
                    subTestCodes.add(refCode.getStateCode());
                }
            }
        }

        if (subTestCodes.isEmpty()) {
            subTestCodes.add("---Dummy---");
            addSetupError("Setup error", "SubTest ID Reference codes are empty.");

        }
        X2Criteria asdCrideria = new X2Criteria();

        asdCrideria.addIn(m_fieldASDSubTestId, subTestCodes);
        asdCrideria.addNotEmpty(m_fieldASDKeystoneCourses, getBroker().getPersistenceKey());

        QueryByCriteria asdQuery = new QueryByCriteria(AssessmentDefinition.class, asdCrideria);
        return getBroker().getCollectionByQuery(asdQuery);
    }

    /**
     * Get the ScheduleDay oid for a schedule and schedule day number.
     *
     * @param sch Schedule
     * @param dayNumber int
     * @return String
     */
    private String getScheduleDayOid(Schedule sch, int dayNumber) {
        Collection<ScheduleDay> days = m_scheduleDays.get(sch.getOid());
        if (days == null) {
            days = sch.getScheduleDays();
            m_scheduleDays.put(sch.getOid(), days);
        }
        for (ScheduleDay day : days) {
            if (day.getNumber() == dayNumber) {
                return day.getOid();
            }
        }
        return "";
    }

    /**
     * Get the SchedulePeriod for a period oid.
     *
     * @param perOid String
     * @return SchedulePeriod
     */
    private SchedulePeriod getSchedulePeriod(String perOid) {
        SchedulePeriod period = m_schedulePeriods.get(perOid);
        if (!m_schedulePeriods.containsKey(perOid)) {
            period = (SchedulePeriod) getBroker().getBeanByOid(SchedulePeriod.class, perOid);
            m_schedulePeriods.put(perOid, period);
        }
        return period;
    }

    /**
     * Populate Map<Course, ReferenceCode>.
     */
    private void initializeCourseMap() {
        if (m_courses == null) {
            m_courses = new HashSet();
        }

        Map<String, Collection<Course>> alternativeCourses = getAlternateCoursesMap();
        Collection<AssessmentDefinition> asdRecords = getASDRecords();

        populateCourseMap(asdRecords, alternativeCourses);
    }

    /**
     * Lookup field aliases and paths.
     *
     */
    private void initializeFields() {
        m_fieldASDSubTestId = translateAliasToJavaName(ALIAS_ASD_SUBTEST_ID, true);
        m_fieldASDKeystoneCourses = translateAliasToJavaName(ALIAS_ASD_PSSA_KEYSTONE_COURSES, true);
        m_fieldCRSAlternative = translateAliasToJavaName(ALIAS_CRS_ALTERNATE, true);

    }

    /**
     * <li>Populate ScheduleTeacher map keyed on MasterSchedule oid.</li>
     * <li>Populate MasterSchedule map keyed on
     * MasterSchedule oid.</li>
     */
    private void initializeTeachersAndSectionMaps() {
        X2Broker broker = getBroker();
        Set<String> coursesOids = new HashSet<String>();

        for (Course crs : m_courses) {
            coursesOids.add(crs.getOid());
        }

        X2Criteria cskCriteria = new X2Criteria();
        cskCriteria.addIn(SchoolCourse.COL_COURSE_OID, coursesOids);
        SubQuery cskSubQuery = new SubQuery(SchoolCourse.class, X2BaseBean.COL_OID, cskCriteria);

        X2Criteria mstCriteria = new X2Criteria();
        mstCriteria.addIn(MasterSchedule.COL_SCHOOL_COURSE_OID, cskSubQuery);
        QueryByCriteria mstQueryByCriteria = new QueryByCriteria(MasterSchedule.class, mstCriteria);
        m_sectionMap = broker.getGroupedCollectionByQuery(mstQueryByCriteria, X2BaseBean.COL_OID, 1024);

        loadSectionTermDayPeriods(mstCriteria);

        X2Criteria mtcCriteria = new X2Criteria();
        SubQuery mstSubQuery = new SubQuery(MasterSchedule.class, X2BaseBean.COL_OID, mstCriteria);
        mtcCriteria.addIn(ScheduleTeacher.COL_SECTION_OID, mstSubQuery);
        QueryByCriteria mtcQueryByCriteria = new QueryByCriteria(ScheduleTeacher.class, mtcCriteria);
        mtcQueryByCriteria.addOrderBy(ScheduleTeacher.COL_SECTION_OID, true);

        m_teachersMap = broker.getGroupedCollectionByQuery(mtcQueryByCriteria, ScheduleTeacher.COL_SECTION_OID, 1024);
    }

    /**
     * Load grade level ref map.
     */
    private void loadGradeLevelRefMap() {
        ReferenceTable gradeLevelRefTable = (ReferenceTable) getBroker().getBeanByOid(ReferenceTable.class,
                ReferenceTable.REF_TABLE_OID_GRADE_LEVEL);
        Map<String, ReferenceCode> gradeLevelMap = gradeLevelRefTable.getCodeMap();

        ExtendedDataDictionary gradeLevelDdx = gradeLevelRefTable.getExtendedDataDictionary();
        DataDictionary gradeLevelDdxDictionary =
                DataDictionary.getDistrictDictionary(gradeLevelDdx, getBroker().getPersistenceKey());
        DataDictionaryField field = gradeLevelDdxDictionary.findDataDictionaryFieldByAlias("NumericGradeLevel");

        Map<String, Integer> gradeLevels = new HashMap<String, Integer>();
        for (ReferenceCode code : gradeLevelMap.values()) {
            String numericLevel = (String) code.getFieldValueByBeanPath(field.getJavaName());
            Integer grade = Integer.parseInt(numericLevel);
            gradeLevels.put(code.getCode(), grade);
        }
        m_gradeLevels = gradeLevels;
    }

    /**
     * Build maps of Section per day periods.
     *
     * @param criteriaMst X2Criteria
     */
    private void loadSectionTermDayPeriods(X2Criteria criteriaMst) {
        // Key is mst, trm, day oids
        X2Criteria criteria = new X2Criteria();
        criteria.addIn(MasterTerm.COL_MASTER_SCHEDULE_OID,
                new SubQuery(MasterSchedule.class, X2BaseBean.COL_OID, criteriaMst));

        String[] columns = new String[] {MasterTerm.COL_MASTER_SCHEDULE_OID,
                MasterTerm.COL_SCHEDULE_TERM_OID,
                MasterTerm.REL_MASTER_MATRICES + PATH_DELIMITER +
                        MasterScheduleMatrix.REL_SCHEDULE_MATRIX + PATH_DELIMITER +
                        ScheduleMatrix.COL_SCHEDULE_DAY_OID,
                MasterTerm.REL_MASTER_MATRICES + PATH_DELIMITER +
                        MasterScheduleMatrix.REL_SCHEDULE_MATRIX + PATH_DELIMITER +
                        ScheduleMatrix.COL_SCHEDULE_PERIOD_OID};

        ReportQueryByCriteria query = new ReportQueryByCriteria(MasterTerm.class, columns, criteria);
        query.addOrderByAscending(MasterTerm.COL_MASTER_SCHEDULE_OID);
        query.addOrderByAscending(MasterTerm.COL_SCHEDULE_TERM_OID);
        query.addOrderByAscending(MasterTerm.REL_MASTER_MATRICES + PATH_DELIMITER +
                MasterScheduleMatrix.REL_SCHEDULE_MATRIX + PATH_DELIMITER +
                ScheduleMatrix.COL_SCHEDULE_DAY_OID);

        ReportQueryIterator iterator = getBroker().getReportQueryIteratorByQuery(query);

        try {
            while (iterator.hasNext()) {
                Object[] row = (Object[]) iterator.next();
                String mstOid = (String) row[0];
                String trmOid = (String) row[1];
                String dayOid = (String) row[2];
                String perOid = (String) row[3];
                String key = mstOid + trmOid + dayOid;

                Collection<ScheduleTerm> terms = m_sectionTermsMap.get(mstOid);
                if (terms == null) {
                    terms = new LinkedList();
                    m_sectionTermsMap.put(mstOid, terms);
                }
                ScheduleTerm term = getScheduleTerm(trmOid);
                if (term != null) {
                    terms.add(term);
                }
                Set<SchedulePeriod> periods = m_sectionTermDayPeriods.get(key);
                if (periods == null) {
                    periods = new HashSet<SchedulePeriod>();
                    m_sectionTermDayPeriods.put(key, periods);
                }
                periods.add(getSchedulePeriod(perOid));
            }
        } finally {
            iterator.close();
        }
    }

    /**
     * Populate Map<Course, ReferenceCode> based on data in the Assessment Definition (ASD).
     *
     * @param asdRecords Collection<AssessmentDefinition>
     * @param alternativeCourses Map<String,Collection<Course>>
     */
    private void populateCourseMap(Collection<AssessmentDefinition> asdRecords,
                                   Map<String, Collection<Course>> alternativeCourses) {
        for (AssessmentDefinition asd : asdRecords) {
            String stateCodesValue = (String) asd.getFieldValueByBeanPath(m_fieldASDKeystoneCourses);
            if (!StringUtils.isEmpty(stateCodesValue)) {
                Set<String> stateCodesSetFromField = new HashSet<String>();
                stateCodesSetFromField.addAll(Arrays.asList(stateCodesValue.split(" *, *")));

                for (String code : stateCodesSetFromField) {
                    Collection<Course> tempCourses = alternativeCourses.get(code);

                    if (tempCourses != null) {
                        for (Course crs : tempCourses) {
                            m_courses.add(crs);

                            if (!m_assessmentMap.containsKey(crs.getOid())) {
                                m_assessmentMap.put(crs.getOid(), new LinkedList());
                            }
                            m_assessmentMap.get(crs.getOid()).add(asd);
                        }
                    }
                }
            }
        }
    }
}
